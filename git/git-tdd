#!/usr/bin/env bash

export PS4='+${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): } '
set -e
set -o pipefail

progname=${0##*/}
trap 'r=$? ; (( 0 == $r )) || echo "$progname: Failed" ; exit $r' EXIT

function usage {
    echo "Usage: $progname <init|show|test|accept>"
}

function help {
    usage
}

function required {
    cat >&2 <<EOM
$progname: Missing git config: $1
Try \`git config --local $1 <value>\` to set $1 for this repository.
EOM
    exit 2
}

function config {
    local opts=(--get)
    while (( 0 < $# ))
    do
        case $1 in
            --bool ) opts=("${opts[@]}" $1) ;;
            -* ) echo "$progname: BUG" >&2 ; exit 3 ;;
            * ) break ;;
        esac
        shift
    done
    local config=tdd.$1
    git config "${opts[@]}" $config 2>/dev/null || echo "${2-required $config}"
}

function show {
    git log -1 --show-notes=tdd "$@"
}

function tdd-notes {
    git notes --ref=tdd "$@"
}

function test-number {
    git log -1 --show-notes=tdd --format=%N 2>/dev/null \
        | sed '/^$/d'
}

function show-config {
    local initial="$1"
    cat <<EOM
Initial commit message (git config tdd.initMessage): $initial
Pull before test (git config tdd.pullBeforeTest): true
Test command (git config --local tdd.testCommand): $(config testCommand)
Accept command (git config --local tdd.acceptCommand): $(config acceptCommand)
EOM
}

function init {
    local quiet=false
    while (( 0 < $# ))
    do
        case $1 in
            --help ) usage ; exit 0 ;;
            -q | --quiet ) quiet=true ;;
            * ) usage >&2 ; exit 2 ;;
        esac
        shift
    done
    if [[ -n "$(test-number)" ]]
    then
        echo "$progname: TDD already initialized" >&2
        exit 2
    fi
    initial="$(config initMessage WIP)"
    if ${FIRST_TIME-true}
    then
        $quiet || show-config "$initial"
        git stash --quiet
        git commit --quiet --allow-empty -m "$initial"
        git stash pop 2>/dev/null || true
    else
        git commit --quiet --allow-empty -m "$initial"
    fi
    tdd-notes add -m 0
}

function test {
    while (( 0 < $# ))
    do
        case $1 in
            --help ) usage ; exit 0 ;;
            * ) usage >&2 ; exit 2 ;;
        esac
    done
    if $(config --bool pullBeforeTest true)
    then
        # Support older git without `git pull --autostash`
        # See http://stackoverflow.com/questions/30208928/can-git-pull-automatically-stash-and-pop-pending-changes
        # TODO: Support even older git (see http://stackoverflow.com/a/31575425)
        # EVEN WORSE - Stash is not well-behaved: http://stackoverflow.com/a/38994123/250924
        local -r stashed_commit=$(git stash create)
        git reset --quiet --hard
        git pull --quiet --rebase
        [[ -n "$stashed_commit" ]] && git stash apply --quiet $stashed_commit
    fi
    $(config testCommand)
    next=$(( $(test-number) + 1 ))
    git commit --quiet -a --amend --no-edit --allow-empty
    # TODO: Cannot distinguish 'Overwriting existing notes' from real error
    tdd-notes add -f -m $next 2>/dev/null
}

function accept {
    while (( 0 < $# ))
    do
        case $1 in
            --help ) usage ; exit 0 ;;
            --message | -m ) local message="$2" ; shift 2 ;;
            * ) usage >&2 ; exit 2 ;;
        esac
    done
    $(config acceptCommand)
    local -r next=$(( $(test-number) + 1 ))
    if [[ -n "$message" ]]
    then
        git commit --quiet -a --amend -m "$message"
    else
        git commit --quiet -a --amend
    fi
    if ! git push --quiet
    then
        # Recover from push hook failure
        local -r rc=$?
        git commit --amend -m WIP
        tdd-notes add -f -m $next 2>/dev/null
        exit $rc
    fi
    FIRST_TIME=false init
}

while (( 0 < $# ))
do
    case $1 in
        --help ) exec man ${0##*/} ;;
        -* ) usage >&2 ; exit 2 ;;
        * ) break ;;
    esac
done

case $# in
    0 ) usage >&2 ; exit 2 ;;
esac

case $1 in
    init | test | accept | show ) "$@" ;;
    * ) usage >&2 ; exit 2 ;;
esac
